OpenMolcas
===========

OpenMolcas is an open-source quantum chemistry package which specializes 
in multiconfigurational approaches to electronic structure. OpenMolcas can be used in tandem 
with PyOpenCAP to perform complex absorbing potential (extended)multi-state complete active 
space second order perturbation theory (CAP/(X)MS-CASPT2) calculations, which have been 
shown to yield accurate energies and lifetimes for metastable electronic states. 
Here, we outline the steps of performing these calculations with our software. We 
assume that the reader is familiar with how to perform multi-reference calculations with OpenMolcas, 
and is familiar with the theory of CAP/(X)MS-CASPT2. Some suggested readings are provided
at the bottom of the page.

Preliminary: Prepare input orbitals
-----------------------------------
As with any multi-reference calculation, the choice of active space is crucial for CAP-(X)MS-CASPT2, 
and is most often guided by chemical intuition. We refer the reader to the OpenMolcas 
manual for how to prepare input orbitals for a state-averaged RASSCF calculation. 

Step 1: Running the OpenMolcas calculation
------------------------------------------
**State-averaged RASSCF**

In order to utilize the Projected CAP approach, a multi-state excited state calculation must be performed.
In the RASSCF module, the keyword 'CIROOT' is used to activate state-averaged RASSCF calculations. The number of 
states required for the averaging varies based on the system and the active space. Setting
the number of states equal to the number of orbitals in the active space is a good starting point. 

.. code-block:: bash

	 &RASSCF
	 CIROOT = 10 10 1

**Export transition densities with RASSI**

The generate the one-particle densities required to construct the CAP matrix, the RASSI 
module must be executed with the TRD1 keyword activated. This keyword saves one-particle 
transition density matrices between each pair of RASSCF states as well as the one-particle 
density matrices for each state to a file titled $Jobname.rassi.h5.

.. code-block:: bash

	 &RASSI
	 TRD1

**Generate effective Hamiltonian with (X)MS-CASPT2**

To generate the zeroth order Hamiltonian, we strongly suggest using the MS-CASPT2 or XMS-CASPT2
approaches. These approaches generate a second-order effective Hamiltonian which describes 
interactions between the different RASSCF states. When the CAP is applied as a perturbation to 
this effective Hamiltonian, we essentially allow the RASSCF states to simultaneously mix under the influence 
of both dynamic correlation and the CAP. In our experience, this approach yields much more accurate 
results for resonances than single-state CASPT2, for which the zeroth order Hamiltonian would
be diagonal. To activate (X)MS-CASPT2 in OpenMolcas, use the Multistate keyword in the CASPT2 
module.

.. code-block:: bash

	&CASPT2
	Multistate = all
	# or
	Xmultistate = all
	
**Ground state energy**

To define the excitation energy of the resonance state, we must know the ground
state energy of the system at the same level of theory. Sometimes the energy of the ground 
and resonance state can be obtained in a single calculation, other times
two separate calculations must be run with the same set of input orbitals 
(e.g. one for the anionic resonance, the other for the neutral ground state). Ensure that 
your ground state energy is defined properly when analyzing the results.


Step 2: Importing the data to PyOpenCAP
---------------------------------------

**System object**

To run a PyOpenCAP calculation, the geometry and basis set must be imported into a System 
object. The constructor exposed to Python takes in a Python dictionary as an argument, with 
key/value pairs which mimic the input file format of the command line version. The relevant
keywords are discussed here, and more information is provided in the keywords page.

*Rassi.h5*

The rassi.h5 file which contains the one-particle densities also contains the geometry 
and basis set information. To read in from rassi, "molcas_rassi" must set as the value to
the key "molecule", and the path to the file must be set as the value to the key 
"basis_file". Here is an example:

.. code-block:: python

	sys_dict = {"molecule": "molcas_rassi","basis_file": "path/to/rassi.h5"}
	my_system = pycap.System(sys_dict)
	
*Molden*

Molden files generated by OpenMolcas contain the geometry and basis set information. 
To read in from molden, "molden" must be set as the value to the key "molecule", and the 
path to the file must be set as the value to the key "basis_file". Here is an example:

.. code-block:: python

	sys_dict = {"molecule": "molden","basis_file": "path/to/file.molden"}
	my_system = pycap.System(sys_dict)

*Manually(not recommended)*

The molecule and basis set can also be specified manually. The "molecule" keyword must 
be set to "read", and then an additional keyword "geometry:" must
be specified, with a string that contains the geometry in xyz format. The "basis_file" keyword 
must be set to a path to a basis set file formatted in Psi4 style, which can be downloaded from
the basis set exchange. Other optional keyword for this section include "bohr_coordinates" and
cart_bf. Please see the keywords section for more details. 

.. code-block:: python

    sys_dict = {"geometry":    '''N  0  0   1.039
                              N  0  0   -1.039
                              X   0  0   0.0''',
            		"molecule" : "read",
            		"basis_file":"path/to/basis.bas",
            		"cart_bf":"d",
            		"bohr_coordinates:": "true"}
    my_system = pycap.System(sys_dict)	

**One particle densities/zeroth order Hamiltonian**

The CAP matrix is computed by the "Projected_CAP" object. The constructor for the Projected_CAP 
object requires a System object, a dictionary containing the CAP parameters, the number of states,
and finally the string "openmolcas", which denotes the ordering of the atomic orbital basis
set. An example is provided below. Please see the keywords section for more information on
the CAP parameters.
  
.. code-block:: python

    cap_dict = {"cap_type": "box",
            	"cap_x":"2.76",
            	"cap_y":"2.76",
            	"cap_z":"4.88",
            	"Radial_precision": "14",
            	"angular_points": "110"}
    pc = pycap.Projected_CAP(my_system,cap_dict,10,"openmolcas")

Before we can compute the CAP matrix in the state basis, we must load in the density matrices.
There are two ways of doing this. The first is to use the "read_data" function of the Projected_CAP
object. As shown below, we define a dictionary which contains the following keys: "method" 
(electronic structure method chosen), "rassi_h5"(density matrices), and "molcas_output"(output file containing effective Hamiltonian).
The effective Hamiltonian can be retrieved using the "get_H" function of the Projected_CAP object. Currently, only the
effective Hamiltonians from (X)MS-CASPT2 calculations can be parsed from an OpenMolcas output file. 
We note that when the read_data function is used, our code symmetrizes the the final result when computing the 
CAP matrix in the state basis.

.. code-block:: python
	
    es_dict = {"method" : "ms-caspt2",
           "molcas_output":"path/to/output.out",
           "rassi_h5":"path/to/rassi.h5"}
    pc.read_data(es_dict)
    # save the effective Hamiltonian for later use
    h0 = pc.get_H()

Alternatively, one can load in the densities one at a time using the "add_tdm(s)" functions.
In our examples below, we load in the matrices from rassi.h5 using the h5py package, and then
pass them as numpy arrays to the Projected_CAP object. This can be particularly useful 
if one wishes to exclude some of the states from the Projected CAP calculation.

.. code-block:: python
	
    import h5py
    f = h5py.File('path/to/rassi.h5', 'r')
    dms = f["SFS_TRANSITION_DENSITIES"]
    # spin traced
    nbasis = int(np.sqrt(dms.shape[2]))
    for i in range(0,10):
        for j in range(i,10):
            dm = 0.5*np.reshape(dms[i][j],(nbasis,nbasis))
            pc.add_tdm(dm,i,j,"openmolcas","path/to/rassi.h5")
            # usually a good idea to symmetrize       
            if i!=j:
                pc.add_tdm(dm,,j,i,"openmolcas","path/to/rassi.h5")
 


Step 3: Computing the CAP matrix
--------------------------------
Once all of the densities are loaded, the CAP matrix is computed 
using the "compute_projected_cap" function. The matrix can be retrieved using the
"get_projected_cap" function.

.. code-block:: python

    pc.compute_projected_cap()
    W_mat=pc.get_projected_cap()


Step 4: Generate eigenvalue trajectories
----------------------------------------
Eigenvalue trajectories by diagonalizing H0-inW over a range of eta values, and then 
analyzing the results. A template (cap_trajectory.py) script is provided in the 
examples/molcas directory of our repository. Automated tools for trajectory analysis
is a subject of future work.


Officially supported methods
----------------------------
The following methods have been benchmarked, and the read_data function is capable of parsing 
output files to obtain the zeroth order Hamiltonian.

* MS-CASPT2
* XMS-CASPT2

Untested (use at your own risk!)
--------------------------------
The following methods are capable of dumping densities using the TRD1 keyword of the RASSI module, 
but have not been benchmarked for any systems, and the zeroth order Hamiltonian cannot be parsed
from the output file using the read_data function. Use at your own caution, and please contact us if you
find success using any of these methods so we can add official support!

* (QD/SS)DMRG-(PC/SC)NEVPT2
* SS-CASPT2
* MC-PDFT

Suggested reading
-----------------

#. Phung, Q. M.; Komori, Y.; Yanai, T.; Sommerfeld, T.; Ehara, M. Combination of a Voronoi-Type Complex Absorbing Potential with the XMS-CASPT2 Method and Pilot Applications. *J. Chem. Theory Comput.* **2020**, 16 (4), 2606–2616.

#. Kunitsa, A. A.; Granovsky, A. A.; Bravaya, K. B. CAP-XMCQDPT2 Method for Molecular Electronic Resonances. *J. Chem. Phys.* **2017**, 146 (18), 184107.

#. Al-Saadon, R.; Shiozaki, T.; Knizia, G. Visualizing Complex-Valued Molecular Orbitals. *J. Phys. Chem. A* **2019**, 123 (14), 3223–3228.