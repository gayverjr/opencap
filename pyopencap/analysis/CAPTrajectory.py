import numpy as np
from numpy import linalg as LA

# https://physics.nist.gov/cgi-bin/cuu/Value?hrev
au2eV = 27.211386245988

def _delete_indices(H0,W,exclude_states):
    exclude_states = np.unique(exclude_states)
    exclude_states = sorted(exclude_states,reverse=True)
    for i in exclude_states:
        H0 = np.delete(H0,i,axis=0)
        H0 = np.delete(H0,i,axis=1)
        W = np.delete(W,i,axis=0)
        W = np.delete(W,i,axis=1)
    return H0,W

class Root():
    '''
    Root obtained from diagonalizing CAP Hamiltonian at given value of eta.
        
    Attributes
    ----------
    eta: float
        CAP strength parameter
    energy: float
        Total energy of state
    eigvc: list of float
        Eigenvector for state
    '''

    def __init__(self, energy, eta, eigvc):
        '''
        Initializes root object.
        
        Parameters
        ----------
        eta: float
            CAP strength parameter
        energy: float
            Total energy of state
        eigvc: list of float
            Eigenvector for state
        '''
        self.eta = eta
        self.energy = energy
        self.eigvc = eigvc

class EigenvalueTrajectory():
    '''
    Eigenvalue trajectory generated by repeated diagonalizations of CAP Hamiltonian over range of eta values. 

    States are tracked using either eigenvector overlap or energy criterion. Corrected energies(U) are obtained as:
    U = E - eta*dE/deta.
    
    Attributes
    ----------
    states: list of :class:`~pyopencap.analysis.Root`
        List of states in trajectory.
    uncorrected_energies: list of float
        List of uncorrected energies in trajectory.
    corrected_energies: list of float
        List of corrected energies in trajectory.
    etas: list of float
        List of CAP strengths in trajectory.
    '''

    def __init__(self,state_idx,init_roots,tracking="overlap"):
        '''
        Initializes EigenvalueTrajectory object, which tracks a state starting from the first diagonalization at eta = 0.
        
        Parameters
        ----------
        state_idx: int
            Index of state to track
        init_roots: list of :class:`~pyopencap.analysis.Root`
            Initial set of roots generated by diagonalization at eta = 0
        tracking: str, default="overlap"
            Method to use to track the state
        '''
        self._last = init_roots[state_idx]
        self.states = [self._last]
        self.uncorrected_energies = [self._last.energy]
        self.corrected_energies = []
        self.etas = [0.0]
        if tracking == "overlap":
            self._add_state = self._overlap_tracking
        elif tracking == "energy":
            self._add_state = self._energy_tracking
        else:
            raise RuntimeError("Invalid choice of tracking. Choose either overlap or energy.")

    def _overlap_tracking(self,states):
        maxo = 0.0
        state_idx = -1
        for st in states:
            ov = np.abs(np.dot(st.eigvc,self._last.eigvc))
            if ov > maxo:
                maxo = ov
                cur = st
        self._last = cur
        self.states.append(cur)
        self.uncorrected_energies.append(cur.energy)
        self.etas.append(cur.eta)

    def _energy_tracking(self,states):
        min= float("inf")
        cur=-1
        for st in states:
            if np.absolute(st.energy-self._last.energy)< min or cur==-1:
                cur=st
                min=np.absolute(st.energy-self._last.energy)
        self._last = cur
        self.states.append(cur)
        self.uncorrected_energies.append(cur.energy)
        self.etas.append(cur.eta)

    def _calculate_corrected_energies(self):
        derivs=list(np.gradient(self.uncorrected_energies)/np.gradient(self.etas))
        # E_cor = E_uc - eta * dE/deta
        for i in range(0,len(self.states)):
            self.corrected_energies.append(self.uncorrected_energies[i]-self.etas[i]*derivs[i])


    def find_eta_opt(self,corrected=False,start_idx=1,end_idx=-1):
        '''
        Finds optimal cap strength parameter for eigenvalue trajectory, as defined by eta_opt = min|eta*dE/deta|.
    
        Parameters
        ----------
        corrected: bool, default=False
            Set to true if searching for stationary point on corrected trajectory
        start_idx: int, default=1
            Point on trajectory to begin the search for the optimal value of eta
        end_idx: int, default=1
        
        Returns
        -------
        E_res: complex float
            Complex energy at optimal value of eta
        eta_opt: float
            Optimal value of eta
        '''
        if corrected:
            derivs=np.array(self.etas)*np.absolute(np.gradient(self.corrected_energies)/np.gradient(self.etas))
            min_val = np.min(derivs[start_idx:end_idx])
            opt_idx = list(derivs).index(min_val)
            return self.corrected_energies[opt_idx],self.etas[opt_idx]
        else:
            derivs=np.array(self.etas)*np.absolute(np.gradient(self.uncorrected_energies)/np.gradient(self.etas))
            min_val = np.min(derivs[start_idx:end_idx])
            opt_idx = list(derivs).index(min_val)
            return self.uncorrected_energies[opt_idx],self.etas[opt_idx]

    def energies_ev(self,ref_energy,corrected=False):
        '''
        Returns excitation energies of all states in trajectory in eV with respect to specified reference energy.
    
        Parameters
        ----------
        ref_energy: float
            Reference energy
        corrected: bool, default=False
            Set to true if analyzing corrected trajectory
        
        Returns
        -------
        E_eV: list of floats
            Excitation energies in eV with respect to specified reference energy.
        '''
        E_eV = []
        if corrected:
            E_hartree = self.corrected_energies
        else:
            E_hartree = self.uncorrected_energies
        for E in E_hartree:
            E_eV.append((E-ref_energy)*au2eV)
        return E_eV

    def get_logarithmic_velocity(self,corrected=False):
        '''
        Returns eta*dE/deta for each point on eigenvalue trajectory. 

        Useful for plotting when dealing with multiple potential stationary points. 
    
        Parameters
        ----------
        ref_energy: float
            Reference energy
        corrected: bool, default=False
            Set to true if analyzing corrected trajectory

        Returns
        -------
        derivs: np.array of float
            eta*dE/deta for each point on eigenvalue trajectory
        '''
        if corrected:
            energies = self.corrected_energies
        else:
            energies = self.uncorrected_energies
        return np.array(self.etas)*np.absolute(np.gradient(energies)/np.gradient(self.etas))

class CAPHamiltonian():
    '''
    Projected CAP Hamiltonian handler for generating eigenvalue trajectories.
    
    Attributes
    ----------
    H0: np.ndarray of float: default=None
        Zeroth order Hamiltonian in state basis
    W: np.ndarray of float: default=None
        CAP matrix in state basis. -1 prefactor is assumed.
    nstates: int
        Number of states 
    total_energies: list of float
        Energies of all states found by repeated diagonalization of CAP Hamiltonian
    etas: list of float
        List of CAP strengths in trajectory.
    cap_lambda: float
        Real CAP strength used for continuum remover CAP. Set to 0.0 by default.
    '''

    def _init_from_matrices(self,H0,W):
        H0 = np.array(H0)
        W = np.array(W)
        assert H0.shape == W.shape
        self.H0 = H0
        self.W = W
        self.nstates = len(H0)
    
    def __init__(self,H0=None,W=None,**kwargs):
        '''
        Initializes CAPHamiltonian object from H0 and W matrix in state basis.

        Object can be initialized in one of two ways. The user can pass H0 and W directly 
        as numpy matrices, or they can specify a path to a properly formatted output file 
        (either OpenCAP or Q-Chem) which contains these two matrices. 

        W matrix is assumed to already have a -1 prefactor, as that is how OpenCAP output is formatted.
        
        Parameters
        ----------
        H0: np.ndarray of float: default=None
            Zeroth order Hamiltonian in state basis
        W: np.ndarray of float: default=None
            CAP matrix in state basis. -1 prefactor is assumed.
        '''
        if H0 is not None and W is not None:
            self._init_from_matrices(H0,W)
        elif "h0_data" in kwargs and "W_data" in kwargs:
            self._init_from_data_files(kwargs["h0_data"],kwargs["W_data"])
        elif "opencap_output" in kwargs:
            self._init_from_opencap_output(kwargs["opencap_output"])
        elif "qchem_output" in kwargs:
            if "irrep" in kwargs:
                self._init_from_qchem_output(kwargs["qchem_output"],irrep=kwargs["irrep"])
            elif "onset" in kwargs:
                self._init_from_qchem_output(kwargs["qchem_output"],onset=kwargs["onset"])
            else:
                self._init_from_qchem_output(kwargs["qchem_output"])
        else:
            raise RuntimeError("Error: Pass either H0 and W keyword arguments, or output_file keyword argument upon instantiation.")

    def _init_from_data_files(self,h0_data_file,W_data_file):
        f = open(h0_data_file,'r')
        H0 = []
        for l in f.readlines():
            arr = l.split()
            arr = [float(x) for x in arr]
            H0+=arr
        num_states = int(np.sqrt(len(H0)))
        H0 = np.reshape(H0,(num_states,num_states))
        f.close()
        self.H0 = H0
        f = open(W_data_file,'r')
        W = []
        for l in f.readlines():
            arr = l.split()
            arr = [float(x) for x in arr]
            W+=arr
        num_states = int(np.sqrt(len(W)))
        W = np.reshape(W,(num_states,num_states))
        f.close()
        assert H0.shape == W.shape
        self.H0 = H0
        self.W = W
        self.nstates = len(H0)

    def _init_from_qchem_eomcc(self,output_file,irrep):
        with open(output_file, 'r') as file:
            filedata = file.readlines()
        cur_idx = -1
        nstates = 0
        for i in range(0,len(filedata)):
            if "Performing Projected CAP-EOM calculation for " + str(irrep) in filedata[i]:
                cur_idx = i+1
                break
        if cur_idx == -1:
            if not irrep=="":
                raise RuntimeError("Error: could not find matrices for " + str(irrep) + " states in " + output_file)
            else:
                raise RuntimeError("Error: could not find matrices in " + output_file)
        nstates = int(filedata[cur_idx].split()[-2])     
        while "Zeroth order Hamiltonian" not in filedata[cur_idx] and cur_idx<len(filedata):
            cur_idx+=1
        cur_idx+=1
        H0 = []
        for i in range(0,nstates):
            l1 = filedata[cur_idx].split()
            l1= [float(x) for x in l1]
            H0+=l1
            cur_idx+=1
        H0 = np.reshape(H0,(nstates,nstates))
        cur_idx+=1
        W = []
        for i in range(0,nstates):
            l1 = filedata[cur_idx].split()
            l1= [float(x) for x in l1]
            W+=l1
            cur_idx+=1
        W = np.reshape(W,(nstates,nstates))
        assert H0.shape == W.shape
        self.H0 = H0
        self.W = W
        self.nstates = len(H0) 

    def _init_from_qchem_adc(self,output_file,onset):
        with open(output_file, 'r') as file:
            filedata = file.readlines()
        cur_idx = -1
        found = False
        for i in range(0,len(filedata)):
            if "Hamiltonian subspace matrix" in filedata[i]:
                cur_idx = i+1
                found = True
                break
        if not found:
            raise RuntimeError("Error: could not find matrices in " + output_file)
        H0 = []
        while cur_idx < len(filedata):
            l1 = filedata[cur_idx].split()
            try:
                l1= [float(x) for x in l1]
                H0+=l1
                cur_idx+=1
            except:
                break
        nstates = len(H0)
        H0 = np.reshape(H0,(nstates,nstates))
        found = False
        for i in range(0,len(filedata)):
            if "The imaginary part of the CAP subspace matrix, onset=" + str(onset) in filedata[i]:
                cur_idx = i+1
                found = True
                break
        if not found:
            raise RuntimeError("Error: could not find matrices in " + output_file)
        W = []
        while cur_idx < len(filedata):
            l1 = filedata[cur_idx].split()
            try:
                l1= [float(x) for x in l1]
                W+=l1
                cur_idx+=1
            except:
                break
        W = np.reshape(W,(nstates,nstates))
        assert H0.shape == W.shape
        self.H0 = H0
        self.W = W
        self.nstates = len(H0) 

    def _init_from_qchem_output(self,output_file,onset="",irrep=""):
        with open(output_file, 'r') as file:
            filedata = file.readlines()
        method=""
        for i in range(0,len(filedata)):
            if "Performing Projected CAP-EOM calculation for " + str(irrep) in filedata[i]:
                method="eomcc"
                break
            elif "The imaginary part of the CAP subspace matrix, onset=" + str(onset) in filedata[i]:
                method="adc"
                break
        if method=="eomcc":
            self._init_from_qchem_eomcc(output_file,irrep)
        elif method=="adc":
            self._init_from_qchem_adc(output_file,onset)
        else:
            raise RuntimeError("Error: Incompatible Q-Chem output.")

    def _init_from_opencap_output(self,output_file):
        with open(output_file, 'r') as file:
            filedata = file.readlines()
        cur_idx = -1
        nstates = 0
        for i in range(0,len(filedata)):
            if "Number of states" in filedata[i]:
                cur_idx = i
                nstates = int(filedata[cur_idx].split()[-1])
                break
        if nstates == 0:
            raise RuntimeError("Error: incompatible output. 0 states found.")
        cur_idx+=2
        # zeroth order hamiltonian first
        H0 = []
        for i in range(0,nstates):
            l1 = filedata[cur_idx].split()
            l1= [float(x) for x in l1]
            H0+=l1
            cur_idx+=1
        H0 = np.reshape(H0,(nstates,nstates))
        cur_idx+=1
        # now CAP matrix
        W = []
        for i in range(0,nstates):
            l1 = filedata[cur_idx].split()
            l1= [float(x) for x in l1]
            W+=l1
            cur_idx+=1
        W = np.reshape(W,(nstates,nstates))
        assert H0.shape == W.shape
        self.H0 = H0
        self.W = W
        self.nstates = len(H0)

    def run_trajectory(self,eta_list,cap_lambda=0.0,exclude_states=[]):
        '''
        Diagonalizes CAP Hamiltonian over range of eta values.

        CAP Hamiltonian is defined as H^CAP = H0 + i*eta*W - cap_lambda * W.
        W matrix is assumed to already have a -1 prefactor, as that is how OpenCAP output is formatted.
        
        Parameters
        ----------
        eta_list: iterable object
            List of eta values to use (recommended range is between 1E-5 and 1E-2, though this can vary widely based on system and CAP shape)
        cap_lambda: float, default=0.0
            Real CAP strength to use for continuum remover CAP
        '''
        if exclude_states is not []:
           H0,W= _delete_indices(self.H0,self.W,exclude_states)
        else:
            H0 = self.H0
            W = self.W
        self._all_roots = []
        self.total_energies = []
        self.cap_lambda = cap_lambda
        self.etas = []
        for i in range(0,len(eta_list)):
            eta=eta_list[i]
            self.etas.append(eta)
            roots = []
            CAPH = H0 +1.0j * eta * W - cap_lambda*W
            eigv,eigvc=LA.eig(CAPH)
            for j,eig in enumerate(eigv):
                roots.append(Root(eigv[j],eta,eigvc[:,j]))
                self.total_energies.append(eigv[j])
            self._all_roots.append(roots)

    def track_state(self,state_idx,tracking="overlap"):
        '''
        Diagonalizes CAP Hamiltonian over range of eta values.

        CAP Hamiltonian is defined as H^CAP = H0 + i*eta*W - cap_lambda * W.
        W matrix is assumed to already have a -1 prefactor, as that is how OpenCAP output is formatted.
        
        Parameters
        ----------
        state_idx: int
            Index of state to track
        tracking: str, default="overlap"
            Method to use to track the state.

        Returns
        -------
        traj: :class:`~pyopencap.analysis.EigenvalueTrajectory`
            Eigenvalue trajectory for further analysis.
        '''
        if len(self._all_roots) == 0:
            raise RuntimeError("Nothing to track. Execute run_trajectory() first.")
        traj = EigenvalueTrajectory(state_idx,self._all_roots[0],tracking=tracking)
        for i in range(1,len(self._all_roots)):
            traj._add_state(self._all_roots[i])
        traj._calculate_corrected_energies()
        return traj

    def energies_ev(self,ref_energy):
        '''
        Returns excitation energies of all calculated states in eV with respect to specified reference energy.
    
        Parameters
        ----------
        ref_energy: float
            Reference energy
        corrected: bool, default=False
            Set to true if analyzing corrected trajectory
        
        Returns
        -------
        E_eV: list of floats
            Excitation energies in eV with respect to specified reference energy.
        '''
        E_eV = []
        for E in self.total_energies:
            E_eV.append((E-ref_energy)*au2eV)
        return E_eV

